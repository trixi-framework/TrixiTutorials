var documenterSearchIndex = {"docs":
[{"location":"differentiable_programming/#Tutorial-2:-Differentiable-programming","page":"Differentiable programming","title":"Tutorial 2: Differentiable programming","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(Image: ) (Image: )","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Julia and its ecosystem provide some tools for differentiable programming. Trixi.jl is designed to be flexible, extendable, and composable with Julia's growing ecosystem for scientific computing and machine learning. Thus, the ultimate goal is to have fast implementations that allow automatic differentiation (AD) without too much hassle for users. If some parts do not meet these requirements, please feel free to open an issue or propose a fix in a PR.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"In the following, we will walk through some examples demonstrating how to differentiate through Trixi.jl.","category":"page"},{"location":"differentiable_programming/#Forward-mode-automatic-differentiation","page":"Differentiable programming","title":"Forward mode automatic differentiation","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Trixi integrates well with ForwardDiff.jl for forward mode AD.","category":"page"},{"location":"differentiable_programming/#Computing-the-Jacobian","page":"Differentiable programming","title":"Computing the Jacobian","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"The high-level interface to compute the Jacobian this way is jacobian_ad_forward.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"using Trixi, LinearAlgebra, Plots","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"equations = CompressibleEulerEquations2D(1.4);\n\nsolver = DGSEM(3, flux_central);\n\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5);\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\nJ = jacobian_ad_forward(semi);","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"size(J)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(1024, 1024)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(1024, 1024)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(1024, 1024)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"λ = eigvals(J);\n\nscatter(real.(λ), imag.(λ));\n\n3.0e-10 < maximum(real, λ) / maximum(abs, λ) < 8.0e-10\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"1.0e-7 < maximum(real, λ) < 5.0e-7\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Interestingly, if we add dissipation by switching to the flux_lax_friedrichs at the interfaces, the maximal real part of the eigenvalues increases.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"solver = DGSEM(3, flux_lax_friedrichs);\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\nJ = jacobian_ad_forward(semi);\n\nλ = eigvals(J);\n\nscatter!(real.(λ), imag.(λ));","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"λ = eigvals(J); round(maximum(real, λ) / maximum(abs, λ), sigdigits=2)\n2.1e-5","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"2.1e-5","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"round(maximum(real, λ), sigdigits=2)\n0.0057","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"0.0057","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"However, we should be careful when using this analysis, since the eigenvectors are not necessarily well-conditioned.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"λ, V = eigen(J);\n\nround(cond(V), sigdigits=2)\n1.8e6","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"1.8e6","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"In one space dimension, the situation is a bit different.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"equations = CompressibleEulerEquations1D(1.4);\n\nsolver = DGSEM(3, flux_central);\n\nmesh = TreeMesh((-1.0,), (1.0,), initial_refinement_level=6, n_cells_max=10^5);\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\nJ = jacobian_ad_forward(semi);\n\nλ = eigvals(J);","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"scatter(real.(λ), imag.(λ));","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"1.0e-16 < maximum(real, λ) / maximum(abs, λ) < 6.0e-16\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"1.0e-12 < maximum(real, λ) < 6.0e-12\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"λ, V = eigen(J);\n\n200 < cond(V) < 300\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"If we add dissipation, the maximal real part is still approximately zero.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"solver = DGSEM(3, flux_lax_friedrichs);\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\nJ = jacobian_ad_forward(semi);\n\nλ = eigvals(J);","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"scatter!(real.(λ), imag.(λ));","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"λ = eigvals(J);\n\n1.0e-18 < maximum(real, λ) / maximum(abs, λ) < 1.0e-16\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"5.0e-14 < maximum(real, λ) < 7.0e-13\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"λ, V = eigen(J);\n\n90_000 < cond(V) < 100_000\ntrue","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Note that the condition number of the eigenvector matrix increases but is still smaller than for the example in 2D.","category":"page"},{"location":"differentiable_programming/#Computing-other-derivatives","page":"Differentiable programming","title":"Computing other derivatives","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"It is also possible to compute derivatives of other dependencies using AD in Trixi. For example, you can compute the gradient of an entropy-dissipative semidiscretization with respect to the ideal gas constant of the compressible Euler equations as described in the following. This example is also available as the elixir examples/special_elixirs/elixir_euler_ad.jl","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"using Trixi, LinearAlgebra, ForwardDiff","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"equations = CompressibleEulerEquations2D(1.4);\n\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5);\n\nsolver = DGSEM(3, flux_lax_friedrichs, VolumeIntegralFluxDifferencing(flux_ranocha));\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_isentropic_vortex, solver);","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"u0_ode = compute_coefficients(0.0, semi);\nsize(u0_ode)\n# (1024,)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(1024,)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"J = ForwardDiff.jacobian((du_ode, γ) -> begin\n        equations_inner = CompressibleEulerEquations2D(first(γ))\n        semi_inner = Trixi.remake(semi, equations=equations_inner, uEltype=eltype(γ));\n        Trixi.rhs!(du_ode, u0_ode, semi_inner, 0.0)\n    end, similar(u0_ode), [1.4]); # γ needs to be an `AbstractArray`\n\nround.(extrema(J), sigdigits=2)\n# (-5.6, 5.6)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(-5.6, 5.6)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Note that we create a semidiscretization semi at first to determine the state u0_ode around which we want to perform the linearization. Next, we wrap the RHS evaluation inside a closure and pass that to ForwardDiff.jacobian. There, we need to make sure that the internal caches are able to store dual numbers from ForwardDiff.jl by setting uEltype appropriately. A similar approach is used by jacobian_ad_forward.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Note that the ideal gas constant does not influence the semidiscrete rate of change of the density, as demonstrated by","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"norm(J[1:4:end])\n# 0.0","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"0.0","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Here, we used some knowledge about the internal memory layout of Trixi, an array of structs with the conserved variables as fastest-varying index in memory.","category":"page"},{"location":"differentiable_programming/#Differentiating-through-a-complete-simulation","page":"Differentiable programming","title":"Differentiating through a complete simulation","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"It is also possible to differentiate through a complete simulation. As an example, let's differentiate the total energy of a simulation using the linear scalar advection equation with respect to the wave number (frequency) of the initial data.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"using Trixi, OrdinaryDiffEq, ForwardDiff, Plots\n\nfunction energy_at_final_time(k) # k is the wave number of the initial condition\n    equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\n    mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\n    solver = DGSEM(3, flux_lax_friedrichs)\n    initial_condition = (x, t, equation) -> begin\n            x_trans = Trixi.x_trans_periodic_2d(x - equation.advectionvelocity * t)\n            return SVector(sinpi(k * sum(x_trans)))\n    end\n    semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                               uEltype=typeof(k))\n    ode = semidiscretize(semi, (0.0, 1.0))\n    sol = solve(ode, BS3(), save_everystep=false)\n    Trixi.integrate(energy_total, sol.u[end], semi)\nend\n# energy_at_final_time (generic function with 1 method)\n\nk_values = range(0.9, 1.1, length=101)\n# 0.9:0.002:1.1","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"0.9:0.002:1.1","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"plot(k_values, energy_at_final_time.(k_values), label=\"Energy\");","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"You should see a plot of a curve that resembles a parabola with local maximum around k = 1.0. Why's that? Well, the domain is fixed but the wave number changes. Thus, if the wave number is not chosen as an integer, the initial condition will not be a smooth periodic function in the given domain. Hence, the dissipative surface flux (flux_lax_friedrichs in this example) will introduce more dissipation. In particular, it will introduce more dissipation for \"less smooth\" initial data, corresponding to wave numbers k further away from integers.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"We can compute the discrete derivative of the energy at the final time with respect to the wave number k as follows.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"# advection_differentiate_simulation\nround(ForwardDiff.derivative(energy_at_final_time, 1.0), sigdigits=2)\n# 1.4e-5","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"1.4e-5","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"This is rather small and we can treat it as zero in comparison to the value of this derivative at other wave numbers k.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"dk_values = ForwardDiff.derivative.((energy_at_final_time,), k_values);\n\nplot(k_values, dk_values, label=\"Derivative\");","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"If you remember basic calculus, a sufficient condition for a local maximum is that the first derivative vanishes and the second derivative is negative. We can also check this discretely.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"# advection_differentiate_simulation\nround(ForwardDiff.derivative(\n        k -> Trixi.ForwardDiff.derivative(energy_at_final_time, k), 1.0),\n      sigdigits=2)\n# -0.9","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"-0.9","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Having seen this application, let's break down what happens step by step.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"function energy_at_final_time(k) # k is the wave number of the initial condition\n    equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\n    mesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\n    solver = DGSEM(3, flux_lax_friedrichs)\n    initial_condition = (x, t, equation) -> begin\n        x_trans = Trixi.x_trans_periodic_2d(x - equation.advectionvelocity * t)\n        return SVector(sinpi(k * sum(x_trans)))\n    end\n    semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                               uEltype=typeof(k))\n    ode = semidiscretize(semi, (0.0, 1.0))\n    sol = solve(ode, BS3(), save_everystep=false)\n    Trixi.integrate(energy_total, sol.u[end], semi)\nend\n\nk = 1.0\nround(ForwardDiff.derivative(energy_at_final_time, k), sigdigits=2)\n# 1.4e-5","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"1.4e-5","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"When calling ForwardDiff.derivative(energy_at_final_time, k) with k=1.0, ForwardDiff.jl will basically use the chain rule and known derivatives of existing basic functions to calculate the derivative of the energy at the final time with respect to the wave number k at k0 = 1.0. To do this, ForwardDiff.jl uses dual numbers, which basically store the result and its derivative w.r.t. a specified parameter at the same time. Thus, we need to make sure that we can treat these ForwardDiff.Dual numbers everywhere during the computation. Fortunately, generic Julia code usually supports these operations. The most basic problem for a developer is to ensure that all types are generic enough, in particular the ones of internal caches.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"The first step in this example creates some basic ingredients of our simulation.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"equations = LinearScalarAdvectionEquation2D(1.0, -0.3)\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=3, n_cells_max=10^4)\nsolver = DGSEM(3, flux_lax_friedrichs)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"┌──────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ DG{Float64}                                                                                      │\n│ ═══════════                                                                                      │\n│ basis: ……………………………………………………………… LobattoLegendreBasis{Float64}(polydeg=3)                         │\n│ mortar: …………………………………………………………… LobattoLegendreMortarL2{Float64}(polydeg=3)                      │\n│ surface integral: ………………………………… SurfaceIntegralWeakForm                                          │\n│ │ surface flux: ……………………………………… FluxLaxFriedrichs(max_abs_speed_naive)                           │\n│ volume integral: …………………………………… VolumeIntegralWeakForm                                           │\n└──────────────────────────────────────────────────────────────────────────────────────────────────┘","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"These do not have internal caches storing intermediate values of the numerical solution, so we do not need to adapt them. In fact, we could also define them outside of energy_at_final_time (but would need to take care of globals or wrap everything in another function).","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Next, we define the initial condition","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"initial_condition = (x, t, equation) -> begin\n    x_trans = Trixi.x_trans_periodic_2d(x - equation.advectionvelocity * t)\n    return SVector(sinpi(k * sum(x_trans)))\nend;","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"as a closure capturing the wave number k passed to energy_at_final_time. If you call energy_at_final_time(1.0), k will be a Float64. Thus, the return values of initial_condition will be SVectors of Float64s. When calculating the ForwardDiff.derivative, k will be a ForwardDiff.Dual number. Hence, the initial_condition will return SVectors of ForwardDiff.Dual numbers.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"The semidiscretization semi uses some internal caches to avoid repeated allocations and speed up the computations, e.g. for numerical fluxes at interfaces. Thus, we need to tell Trixi to allow ForwardDiff.Dual numbers in these caches. That's what the keyword argument uEltype=typeof(k) in","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"semi = SemidiscretizationHyperbolic(mesh, equations, initial_condition, solver,\n                                    uEltype=typeof(k))","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"┌──────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ SemidiscretizationHyperbolic                                                                     │\n│ ════════════════════════════                                                                     │\n│ #spatial dimensions: ………………………… 2                                                                │\n│ mesh: ………………………………………………………………… TreeMesh{2, Trixi.SerialTree{2}} with length 85                  │\n│ equations: …………………………………………………… LinearScalarAdvectionEquation2D                                  │\n│ initial condition: ……………………………… #9                                                               │\n│ boundary conditions: ………………………… Trixi.BoundaryConditionPeriodic                                  │\n│ source terms: …………………………………………… nothing                                                          │\n│ solver: …………………………………………………………… DG                                                               │\n│ total #DOFs: ……………………………………………… 1024                                                             │\n└──────────────────────────────────────────────────────────────────────────────────────────────────┘","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"does. This is basically the only part where you need to modify your standard Trixi code to enable automatic differentiation. From there on, the remaining steps","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"ode = semidiscretize(semi, (0.0, 1.0))\nsol = solve(ode, BS3(), save_everystep=false)\nTrixi.integrate(energy_total, sol.u[end], semi)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"0.24985580923677064","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"do not need any modifications since they are sufficiently generic (and enough effort has been spend to allow general types inside these calls).","category":"page"},{"location":"differentiable_programming/#Propagating-errors-using-Measurements.jl","page":"Differentiable programming","title":"Propagating errors using Measurements.jl","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(Image: Error bars by Randall Munroe)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Similar to AD, Trixi also allows propagating uncertainties using linear error propagation theory via Measurements.jl. As an example, let's create a system representing the linear advection equation in 1D with an uncertain velocity. Then, we create a semidiscretization using a sine wave as initial condition, solve the ODE, and plot the resulting uncertainties in the primitive variables.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"using Trixi, OrdinaryDiffEq, Measurements, Plots, LaTeXStrings\n\nequations = LinearScalarAdvectionEquation1D(1.0 ± 0.1);\n\nmesh = TreeMesh((-1.0,), (1.0,), n_cells_max=10^5, initial_refinement_level=5);\n\nsolver = DGSEM(3);\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test,\n                                    solver, uEltype=Measurement{Float64});\n\node = semidiscretize(semi, (0.0, 1.5));\n\nsol = solve(ode, BS3(), save_everystep=false);\n\nplot(sol)","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(Image: )","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"You should see a plot like the following, where small error bars are shown around the extrema and larger error bars are shown in the remaining parts. This result is in accordance with expectations. Indeed, the uncertain propagation speed will affect the extrema less since the local variation of the solution is relatively small there. In contrast, the local variation of the solution is large around the turning points of the sine wave, so the uncertainties will be relatively large there.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"All this is possible due to allowing generic types and having good abstractions in Julia that allow packages to work together seamlessly.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"(Image: tutorial_measurements1)","category":"page"},{"location":"differentiable_programming/#Finite-difference-approximations","page":"Differentiable programming","title":"Finite difference approximations","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"Trixi provides the convenience function jacobian_fd to approximate the Jacobian via central finite differences.","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"using Trixi, LinearAlgebra\n\nequations = CompressibleEulerEquations2D(1.4);\n\nsolver = DGSEM(3, flux_central);\n\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5);\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_density_wave, solver);\n\nJ_fd = jacobian_fd(semi);\n\nJ_ad = jacobian_ad_forward(semi);\n\nround(norm(J_fd - J_ad) / size(J_fd, 1), sigdigits=2)\n# 6.7e-7","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"5.9e-7","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"This discrepancy is of the expected order of magnitude for central finite difference approximations.","category":"page"},{"location":"differentiable_programming/#Linear-systems","page":"Differentiable programming","title":"Linear systems","text":"","category":"section"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"When a linear PDE is discretized using a linear scheme such as a standard DG method, the resulting semidiscretization yields an affine ODE of the form","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"partial_t u(t) = A u(t) + b","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"where A is a linear operator (\"matrix\") and b is a vector. Trixi allows you to obtain this linear structure in a matrix-free way by using linear_structure. The resulting operator A can be used in multiplication, e.g. mul! from LinearAlgebra, converted to a sparse matrix using sparse from SparseArrays, or converted to a dense matrix using Matrix for detailed eigenvalue analyses. For example,","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"using Trixi, LinearAlgebra, Plots\n\nequations = LinearScalarAdvectionEquation2D(1.0, -0.3);\n\nsolver = DGSEM(3, flux_lax_friedrichs);\n\nmesh = TreeMesh((-1.0, -1.0), (1.0, 1.0), initial_refinement_level=2, n_cells_max=10^5);\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_convergence_test, solver);\n\nA, b = linear_structure(semi);\n\nsize(A), size(b)\n# ((256, 256), (256,))","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"((256, 256), (256,))","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"λ = eigvals(Matrix(A));\n\nscatter(real.(λ), imag.(λ));\n\nλ = eigvals(Matrix(A)); maximum(real, λ) / maximum(abs, λ) < 1.0e-15\n# true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"true","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"","category":"page"},{"location":"differentiable_programming/","page":"Differentiable programming","title":"Differentiable programming","text":"This page was generated using Literate.jl.","category":"page"},{"location":"adding_a_new_equation/#Tutorial-1:-Adding-a-new-equation","page":"Adding a new equation","title":"Tutorial 1: Adding a new equation","text":"","category":"section"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"(Image: ) (Image: )","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"If you want to use Trixi for your own research, you might be interested in a new physics model that's not already included in Trixi.jl. In this tutorial, we will implement the cubic conservation law","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"partial_t u(tx) + partial_x u(tx)^3 = 0","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"in a periodic domain in one space dimension. In Trixi.jl, such a mathematical model is encoded as a subtype of (AbstractEquations).","category":"page"},{"location":"adding_a_new_equation/#Basic-setup","page":"Adding a new equation","title":"Basic setup","text":"","category":"section"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"Let's start by creating a module (in the REPL, in a file, in a Jupyter notebook, ...). That ensures that we can re-create structs defined therein without having to restart Julia.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"module CubicConservationLaw\n\nusing Trixi\n\nstruct CubicEquation <: Trixi.AbstractEquations{1 #= number of spatial dimensions =#,\n                                                1 #= number of primary variables, i.e. scalar =#};\nend\n\nend; # module","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"We create CubicEquation as an empty struct since we do not use any parameters for this equation. Other models could bundle arbitrary parameters, e.g., the ideal gas constant for the compressible Euler equations.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"From here on, the following code snippets normally are written inside the module. To make this work outside CubicConservationLaw.CubicEquation is used instead of CubicEquation. The complete code can be found at the end. Next, we define the physical flux f(u) = u^3 using the calling structure used in Trixi.jl.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"using Trixi\n\nTrixi.flux(u, orientation, equation::CubicConservationLaw.CubicEquation) = u.^3\nTrixi.varnames(_, ::CubicConservationLaw.CubicEquation) = (\"scalar\",)","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"In Trixi.jl, the conserved variables u are usually passed as SVectors of variables at a single physical location. Hence, we must use u.^3 instead of the scalar operation u^3.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"That's already enough to run a simple simulation with a standard DGSEM discretization using the non-dissipative central flux at interfaces. This code is written outside of our new module.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"# Create a simulation setup\nusing OrdinaryDiffEq\n\nequation = CubicConservationLaw.CubicEquation()\n\ninitial_condition_sine(x, t, equation::CubicConservationLaw.CubicEquation) = SVector(sinpi(x[1]))\n\nmesh = TreeMesh(-1.0, 1.0, # min/max coordinates\n                initial_refinement_level=4,\n                n_cells_max=10^4)\n\nsolver = DGSEM(3 #= polynomial degree =#, flux_central)\n\nsemi = SemidiscretizationHyperbolic(mesh, equation, initial_condition_sine, solver)\n\n# Create ODE problem with given time span\ntspan = (0.0, 0.09)\node = semidiscretize(semi, tspan);","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"We wrap the return value of the initial_condition_sine inside an SVector since that's the approach used in Trixi.jl also for systems of equations. We need to index the spatial coordinate x[1], since it is an SVector with one component. In multiple space dimensions, all spatial coordinates are passed together.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"The ode is an ODEProblem from the SciML/DifferentialEquations ecosystem. Thus, we can solve this ODE numerically using any time integration method, e.g., SSPRK43 from OrdinaryDiffEq.jl. Before, we set up a callback to summarize the simulation setup.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"summary_callback = SummaryCallback()\ncallbacks = CallbackSet(summary_callback)\n\n# OrdinaryDiffEq's `solve` method evolves the solution in time and executes the passed callbacks\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks, maxiters=1e5);\n\n# Print the timer summary\nsummary_callback()","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"\n████████╗██████╗ ██╗██╗  ██╗██╗\n╚══██╔══╝██╔══██╗██║╚██╗██╔╝██║\n   ██║   ██████╔╝██║ ╚███╔╝ ██║\n   ██║   ██╔══██╗██║ ██╔██╗ ██║\n   ██║   ██║  ██║██║██╔╝ ██╗██║\n   ╚═╝   ╚═╝  ╚═╝╚═╝╚═╝  ╚═╝╚═╝\n\n┌──────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ SemidiscretizationHyperbolic                                                                     │\n│ ════════════════════════════                                                                     │\n│ #spatial dimensions: ………………………… 1                                                                │\n│ mesh: ………………………………………………………………… TreeMesh{1, Trixi.SerialTree{1}} with length 31                  │\n│ equations: …………………………………………………… CubicEquation                                                    │\n│ initial condition: ……………………………… initial_condition_sine                                           │\n│ boundary conditions: ………………………… Trixi.BoundaryConditionPeriodic                                  │\n│ source terms: …………………………………………… nothing                                                          │\n│ solver: …………………………………………………………… DG                                                               │\n│ total #DOFs: ……………………………………………… 64                                                               │\n└──────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ TreeMesh{1, Trixi.SerialTree{1}}                                                                 │\n│ ════════════════════════════════                                                                 │\n│ center: …………………………………………………………… [0.0]                                                            │\n│ length: …………………………………………………………… 2.0                                                              │\n│ periodicity: ……………………………………………… (true,)                                                          │\n│ current #cells: ……………………………………… 31                                                               │\n│ maximum #cells: ……………………………………… 10000                                                            │\n└──────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ CubicEquation                                                                                    │\n│ ═════════════                                                                                    │\n│ #variables: ………………………………………………… 1                                                                │\n│ │ variable 1: …………………………………………… scalar                                                           │\n└──────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ DG{Float64}                                                                                      │\n│ ═══════════                                                                                      │\n│ basis: ……………………………………………………………… LobattoLegendreBasis{Float64}(polydeg=3)                         │\n│ mortar: …………………………………………………………… LobattoLegendreMortarL2{Float64}(polydeg=3)                      │\n│ surface integral: ………………………………… SurfaceIntegralWeakForm                                          │\n│ │ surface flux: ……………………………………… flux_central                                                     │\n│ volume integral: …………………………………… VolumeIntegralWeakForm                                           │\n└──────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ Time integration                                                                                 │\n│ ════════════════                                                                                 │\n│ Start time: ………………………………………………… 0.0                                                              │\n│ Final time: ………………………………………………… 0.09                                                             │\n│ time integrator: …………………………………… SSPRK43                                                          │\n└──────────────────────────────────────────────────────────────────────────────────────────────────┘\n ──────────────────────────────────────────────────────────────────────────────\n            Trixi.jl                   Time                   Allocations      \n                               ──────────────────────   ───────────────────────\n       Tot / % measured:            213ms / 100%            4.78MiB / 100%     \n\n Section               ncalls     time   %tot     avg     alloc   %tot      avg\n ──────────────────────────────────────────────────────────────────────────────\n rhs!                      58    212ms   100%  3.66ms   4.78MiB  100%   84.3KiB\n   ~rhs!~                  58    212ms   100%  3.66ms   4.78MiB  100%   84.3KiB\n   volume integral         58   18.2μs  0.01%   314ns     0.00B  0.00%    0.00B\n   interface flux          58   8.10μs  0.00%   140ns     0.00B  0.00%    0.00B\n   prolong2interfaces      58   7.20μs  0.00%   124ns     0.00B  0.00%    0.00B\n   surface integral        58   4.90μs  0.00%  84.5ns     0.00B  0.00%    0.00B\n   Jacobian                58   4.40μs  0.00%  75.9ns     0.00B  0.00%    0.00B\n   prolong2boundaries      58   2.50μs  0.00%  43.1ns     0.00B  0.00%    0.00B\n   reset ∂u/∂t             58   2.40μs  0.00%  41.4ns     0.00B  0.00%    0.00B\n   source terms            58   2.00μs  0.00%  34.5ns     0.00B  0.00%    0.00B\n   boundary flux           58   1.70μs  0.00%  29.3ns     0.00B  0.00%    0.00B\n ──────────────────────────────────────────────────────────────────────────────\n\n","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"That's it, you ran your first simulation using your new equation with Trixi! Now, we can plot the solution at the final time using Plots.jl.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"using Plots\nplot(sol)","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"(Image: )","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"You can already see that discontinuities will develop and oscillations start to occur around steep parts of the wave. That's expected from our central discretization. To avoid these issues, we need to use dissipative numerical fluxes (approximate Riemann solvers) at interfaces.","category":"page"},{"location":"adding_a_new_equation/#Advanced-setup","page":"Adding a new equation","title":"Advanced setup","text":"","category":"section"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"Thus, we add a Godunov's flux for our cubic equation. That is easy for this equation since the wave speed f'(u) = 3u^2 is always non-negative.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"@inline Trixi.flux_godunov(u_ll, u_rr, orientation, equation::CubicConservationLaw.CubicEquation) = flux(u_ll, orientation, equation)","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"Let's run the example again but with a dissipative numerical flux at interfaces. remake will recreate the semidiscretization we used before and only change selected parameters, in this case the solver.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"# A new setup with dissipation\nsemi = remake(semi, solver=DGSEM(3, flux_godunov))\node = semidiscretize(semi, tspan)\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks, maxiters=1e5);\nsummary_callback()\nplot!(sol)","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"(Image: )","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"You can see that there are fewer oscillations, in particular around steep edges. Now let's increase the final time (and also the spatial resolution).","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"# A larger final time: Nonclassical shocks develop (you can even increase the refinement to 12)\nsemi = remake(semi, mesh=TreeMesh(-1.0, 1.0, initial_refinement_level=8, n_cells_max=10^5))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks, maxiters=1e5);\nplot(sol)","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"(Image: )","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"You can observe that nonclassical shocks develop and are stable under grid refinement, e.g. for initial_refinement_level=12. In this case, these nonclassical shocks can be avoided by using an entropy-dissipative semidiscretization. Thus, we need to define an entropy-conservative numerical flux","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"@inline function Trixi.flux_ec(u_ll, u_rr, orientation, equation::CubicConservationLaw.CubicEquation)\n  return SVector(0.25 * (u_ll[1]^3 + u_ll[1]^2 * u_rr[1] + u_ll[1] * u_rr[1]^2 + u_rr[1]^3))\nend","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"and use a (VolumeIntegralFluxDifferencing) instead of the standard (VolumeIntegralWeakForm) in the DGSEM.","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"# Let's use a provably entropy-dissipative semidiscretization\nsemi = remake(semi, solver=DGSEM(3, flux_godunov, VolumeIntegralFluxDifferencing(flux_ec)))\node = semidiscretize(semi, (0.0, 0.5))\nsol = solve(ode, SSPRK43(),\n            save_everystep=false, callback=callbacks, maxiters=1e5);\nplot(sol)","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"(Image: )","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"Possible next steps could be","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"to define Trixi.max_abs_speeds(u, equations::CubicEquation) = 3 * u[1]^2 to use CFL_based time step control via a (StepsizeCallback)\nto define quantities of interest like Trixi.entropy(u, equations::CubicEquation) = u[1]^2 and integrate them in a simulation using the (AnalysisCallback)\nto experiment with shock-capturing volume integrals (VolumeIntegralShockCapturingHG) and adaptive mesh refinement (AMRCallback)","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"","category":"page"},{"location":"adding_a_new_equation/","page":"Adding a new equation","title":"Adding a new equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Welcome-to-TrixiTutorials","page":"Introduction","title":"Welcome to TrixiTutorials","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: ) (Image: )","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Working with somebody else's code often is hard in the beginning. To simplify the start looking into an example might help. It is even more helpful if you can run the example by yourself and see what single lines or some commands will do. So, in this tutorial section you have the possibility to do exactly this. There are three ways to use these tutorials:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you have not much time or just want to look quickly in the example, you can use the documentation page.\nFor a deeper look there is a not interactive way with nbviewer where the code is already executed.\nTo take full advantage you can use the interactive notebook version of the tutorials where you can run the code by yourself. To get there just click on the binder logo within the corresponding tutorial.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This page was generated using Literate.jl.","category":"page"}]
}
